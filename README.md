# flask api

## Локальный запуск

### Требования

Перед началом убедитесь, что у вас установлены следующие инструменты:

* [Docker](https://www.docker.com/get-started) и [Docker Compose](https://docs.docker.com/compose/install/)
* [Git](https://git-scm.com/downloads)

### Инструкция по запуску

Выполните следующие шаги для настройки и запуска проекта.

**1. Клонируйте репозиторий:**

Откройте терминал и выполните следующую команду, чтобы клонировать репозиторий и перейти в его директорию:

```bash
git clone https://github.com/ztvgzh/flask_api
cd flask_api/
```

**2. Создайте файл окружения:**

Создайте копию файла с примерами переменных окружения (в проекте уже есть .env):

```bash
cp .env.example .env
```

После этого откройте файл `.env` в текстовом редакторе и установите необходимые значения для подключения к базе данных и других настроек.

**3. Запустите приложение:**

Используйте Docker Compose для сборки и запуска контейнеров в фоновом режиме:

```bash
docker-compose up -d
```

**4. Проверьте работу:**

Чтобы убедиться, что приложение успешно запущено, отправьте тестовый запрос к эндпоинту `/ping`:

```bash
curl http://localhost:5000/ping
```

В ответ вы должны получить: `{"status":"Ok"}`

### Примеры использования API

Ниже приведены примеры взаимодействия с основными эндпоинтами API.

### 1. Проверка статуса

Эндпоинт для проверки доступности сервиса.

**Запрос:**

```bash
curl http://localhost:5000/ping
```

**Ответ:**

```json
{
  "status": "ok"
}
```

---

### 2. Создание записи

Создает новую запись с именем и результатом.

**Запрос:**

```bash
curl -X POST http://localhost:5000/submit \
     -H "Content-Type: application/json" \
     -d '{"name": "Kirill", "score": 88}'
```

**Ответ:**

```json
{
  "message": "Record created successfully",
  "record": {
    "id": 1,
    "name": "Kirill",
    "score": 88,
    "timestamp": "2025-05-30T10:25:43"
  }
}
```

---

### 3. Получение всех записей

Возвращает список всех сохраненных записей.

**Запрос:**

```bash
curl http://localhost:5000/results
```

**Ответ:**

```json
[
  {
    "id": 1,
    "name": "Kirill",
    "score": 88,
    "timestamp": "2025-05-30T10:25:43"
  }
]
```



## Настройка Jenkins

### Требования

Убедитесь, что на вашем сервере Jenkins установлены следующие плагины:

* **Docker Pipeline**
* **SSH Agent**
* **Git**

---

### Настройка Credentials SSH

Для развертывания на целевом сервере необходимо настроить SSH-ключи в Jenkins.

1.  Перейдите в `Manage Jenkins` > `Credentials`.
2.  Добавьте новые учетные данные (**credentials**).
3.  **Тип**: `SSH Username with private key`.
4.  **ID**: `ssh-credentials` (или другое ID, указанное в вашем Jenkinsfile).
5.  Укажите имя пользователя и вставьте ваш приватный SSH-ключ.

---

### Настройка Pipeline

1.  Создайте новый элемент (**New Item**) в Jenkins и выберите **Pipeline**.
2.  В настройках проекта, в разделе **Pipeline**, выберите опцию **Pipeline script from SCM**.
3.  **SCM**: выберите **Git**.
4.  **Repository URL**: укажите URL вашего Git-репозитория.
5.  Убедитесь, что файл `Jenkinsfile` находится в корневой директории вашего проекта.

---

## CI/CD Pipeline

Пайплайн автоматизирует весь процесс от получения кода до развертывания и состоит из следующих этапов:

* **Checkout**: Получение исходного кода из Git-репозитория.
* **Build**: Сборка Docker-образа приложения.
* **Test/Lint**: Проверка качества кода с помощью статического анализатора `flake8`.
* **Push**: Загрузка собранного образа в Docker Registry.
* **Deploy**: Автоматическое развертывание новой версии на целевом сервере.

---

### Процесс развертывания

Развертывание на целевом сервере происходит автоматически.

* Для управления контейнерами используется **docker-compose**.
* Перед запуском новой версии приложения старые контейнеры корректно останавливаются.
* После успешного развертывания выполняется очистка системы от неиспользуемых Docker-образов для освобождения дискового пространства.

Пример **Endpoint: http://37.9.53.18:5000/results
**
